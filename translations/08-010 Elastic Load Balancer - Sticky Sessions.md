---
source: 08 - High Availability and Scalability ELB & ASG\010 Elastic Load Balancer - Sticky Sessions_zh.srt
---

教师：我们来谈谈粘性会话,

也称为弹性负载均衡器的会话关联｡

因此, 可以实现所谓的粘性或粘性会话,

其思想是向负载均衡器发出两个请求的客户端将在后端具有相同的实例来响应请求｡

例如, 您有一个带有两个EC2实例的ALB,

并且您有三个客户端｡

如果客户端发出一个请求,

并且它转到第一个EC2实例,

这意味着当它向负载均衡器发出第二个请求时,

它将转到同一个实例｡

这是一种不同的行为,

通常应用程序负载均衡器会将所有请求分散到所有EC2实例中｡

现在对于客户端2, 如果它转到ALB并与第二个实例对话,

则所有请求都将转到那里｡

客户3也是如此｡ 

好吗？

因此, 可以为经典负载平衡器､

应用程序负载平衡器和网络负载平衡器启用此功能｡ 至于其工作原理,

有一个cookie作为请求的一部分从客户端的两个负载平衡器发送｡

它具有粘性和到期日期, 这意味着当cookie到期时,

客户端可能会被重定向到另一个EC2实例｡

这种情况的用例是确保用户连接到相同的后端实例,

以免丢失其会话数据｡

它可以获取一些重要信息,

例如用户的登录｡

但是如果你开启粘性,

可能会带来后端EC2实例负载不平衡的问题,

比如有的实例我有一个非常非常粘性的用户｡

好的｡ 

现在再深入一点,

关于饼干本身呢？

有两种类型的cookie可以用于粘性会话｡

第一种是基于应用程序的cookie,

第二种是基于持续时间的cookie｡

因此, 对于基于应用程序的cookie,

它是由目标生成的自定义cookie, 因此由您的应用程序本身生成｡

您还可以根据应用程序的需要包含任何自定义属性｡

必须为每个目标组单独指定cookie名称,

好吗？

并且您不能使用以下名称, 例如AWSALB､

AWSALBAPP或AWSALBTG, 因为它们已经保留供ALB本身使用｡

或者它可以是应用程序cookie,

并且这个时间将由负载均衡器本身生成｡

ALB使用的cookie名称将是AWSALBAPP｡ 

好吗？

第二种类型的cookie是基于持续时间的cookie,

它是由负载均衡器生成的cookie｡

名字是AWSALB代表ALB, AWSELB代表CLB｡

好吗？

这个想法是这个将有一个基于特定持续时间的到期日,

持续时间由负载均衡器本身生成｡

好吗？

而在此之前, 有一个基于应用程序的cookie,

因此持续时间可以由应用程序本身指定｡

这就是它的工作原理, 好吗？

您不需要确切地记住cookie的名称或您有自定义和应用程序的事实,

但您记得有基于应用程序的cookie和基于持续时间的cookie, 它们有一个特定的名称, 当我们谈论CloudFront时, 这将被考虑在内｡

好吗？

如果我现在查看我的负载均衡器,

并在新选项卡中打开它, 您可以看到它在负载均衡器中的三个实例之间运行｡

所以这是完美的｡ 

但现在我要启用粘滞会话｡ 

为此, 我将转到目标组级别, 打开我的目标组,

然后Action｡

我将可以编辑我的目标组的属性｡ 

在底部我有粘性或粘性会话｡ 

正如我们所看到的,

我们有两种类型的粘性｡

好吗？

我们有负载平衡器生成的cookie,

它是一种持续时间类型的粘性｡

所以我可以说在一秒到七天之间｡ 

或者, 我可以使用基于应用程序的cookie,

同样是1秒到7天, 但这一次我需要指定应用程序发送给负载均衡器的cookie名称｡

所以它可能是我的定制饼干｡ 

这就是负载均衡器用来执行粘性的东西｡

好吗？

粘性就是这样｡ 

正如我们所看到的,

如果我们只是有一个负载平衡器生成的cookie,

我们设置粘性持续时间等于一天, 我将保存这个更改｡

现在让我们来看看｡ 

所以我也要打开调试器, 这样我们就可以看看网络,

看看会发生什么｡

所以如果我们看一下网络,

然后我刷新这个页面, 正如我们所看到的,

我刷新了多次｡

好吗？

您可以访问同一个实例｡ 

所以7-176是一个回来,

回来, 回来, 回来｡

现在将要发生的是, 当你看到向负载均衡器发出的GET请求时,

我非常非常抱歉这里的字体大小,

我不认为我真的可以增加它｡

但是如果你去Cookie, 正如你在这里看到的,

有一个响应cookie, 好吗？

这意味着您的cookie将于明天到期｡ 

这里是路径, 这里是cookie的值｡

然后在请求cookie中,

当浏览器向负载平衡器发出请求时, 它会再次发送它在这里拥有的cookie｡

由于cookie被传递和发送, 这就是粘性的工作方式｡

好吗？

我们来深入探讨一下粘性是如何工作的｡

但这就是这节课的内容, 我希望你们喜欢｡

顺便说一下, 要访问Web开发人员工具, 请单击Web Developer, 然后单击Web

Developer Tools｡

我用了一条捷径｡ 

在Chrome和Firefox上也是如此｡ 

然后你进入网络,

你可以访问你的信息围绕你的请求｡

好吗？

最后, 只要回到你的目标群体,

然后你编辑属性本身, 你可以禁用粘性回到正常的行为｡

我们应该可以走了｡ 

这就是今天的讲座, 我希望你们喜欢｡ 

我们下节课再见｡
