---
source: 11 - Classic Solutions Architecture Discussions\003 MyClothes.com_zh.srt
---

在上一节课中, 我们讨论了一个无状态的Web应用程序｡ 

现在几点了｡  com？

只要输入时间｡ 

我们不需要任何数据库或任何信息, 外部信息来回答这个问题｡ 

但是现在我们将进入一个名为Michaels的有状态Web应用程序｡  com.

还有迈克尔 com允许人们在线购买衣服, 当你浏览Michaels时, 会有一个购物车｡

com.

我们同时拥有数百名用户｡ 

因此, 所有这些用户都在浏览网站, 我们希望能够扩展, 保持水平可扩展性,

并使我们的应用程序Web层尽可能无状态｡

因此, 即使存在购物车状态, 我们也希望能够尽可能轻松地扩展我们的Web应用程序｡

因此, 用户, 这意味着他们不应该失去他们的购物车, 而导航我们的网站｡ 

这将是非常糟糕的, 也许也有他们的详细信息, 如地址等在一个数据库,

我们可以有效地存储, 并使从任何地方访问｡

所以让我们看看我们如何继续｡ 

你会看到这将是另一个有趣但具有挑战性的讨论｡ 

好了, 这是我们的应用程序, 我会说得很快｡ 

这是我们在上节课中看到的建筑｡ 

因此, 我们将用户路由53 Multi-az ELB自动缩放组3作为非常基本的路由｡ 

所以我们的应用程序访问我们的ELB, 我们的ELB说, 好吧, 你要和这个实例对话,

你创建一个购物车, 然后下一个请求不会去同一个实例, 而是去另一个实例｡

现在购物车丢失了, 用户说, 哦, 那一定是个小bug, 我要再试一次｡

所以他在购物车中添加了一些东西, 然后它被重定向到第三个实例, 这个实例没有购物车｡

所以基本上用户会发疯, 说, 等等, 我每次做一些事情都会失去我的购物车｡ 

这真的很奇怪

麦可 com是一个糟糕的网站｡ 

我不想在上面买东西｡ 

我们还赔了钱｡ 

那我们该怎么解决

我们可以引入粘性或会话关联性, 这是ELB特性｡ 

因此, 我们启用ELB粘性｡ 

现在我们的用户与我们的第一个实例对话, 将一些东西添加到购物车中｡ 

然后第二个请求由于粘性而转到同一个实例｡ 

第三个请求也发往同一个实例｡ 

实际上, 由于粘性, 每个请求都会转到同一个实例｡ 

这非常有效, 但是如果一个EC2实例由于某种原因被终止, 那么我们仍然会丢失我们的购物车｡

但由于粘性和会话亲和力, 这里肯定有某种改进｡ 

现在让我们来看看一种完全不同的方法, 并介绍用户cookie｡ 

因此, 基本上不是让EC2实例存储购物车的内容, 而是让用户存储购物车内容｡

所以每次它连接到负载均衡器时, 它基本上都会说, 顺便说一下, 在我的购物车里,

我有所有这些东西, 这是通过网络cookie完成的｡

因此, 如果它与第一台服务器､ 第二台服务器或第三台服务器通信, 每台服务器都将知道购物车内容是什么,

因为用户是直接将购物车内容发送到我们的EC2实例的人｡

很酷吧？

我们已经实现了无状态, 因为现在每个EC2实例都不需要知道之前发生了什么｡ 

用户会告诉我们之前发生了什么, 但是Http请求, 他们变得越来越重｡ 

因此, 由于我们在Web Cookie中发送购物车内容, 因此每次向购物车添加内容时,

我们都会发送越来越多的数据｡

此外, 还有一定程度的安全风险, 因为cookie可能会被攻击者更改｡

因此, 也许我们的用户可能会突然修改购物车｡ 

因此, 当我们有这种架构时, 请确保您的EC2实例验证用户cookie的内容,

然后验证cookie｡

总的来说, 它们只能这么大, 它们总共只能少于四千字节｡ 

所以你只能在cookie中存储一点信息｡ 

您无法存储大数据集｡ 

好吧, 这就是我的想法｡ 

所以这个很好用｡ 

这实际上是许多Web应用程序框架使用的模式｡ 

但如果我们做点别的呢？

让我们介绍服务器会话的概念｡ 

因此, 现在不是在web cookie中发送整个购物车, 而是发送一个会话ID,

该会话ID仅为用户｡

所以我们要发送这个, 在后台我们可能会有一个Elasticsearch集群｡ 

当我们发送一个会话ID时, 我们将与一个EC2实例对话, 并说我们将把这个东西添加到购物车中｡

因此, EC2实例会将购物车内容添加到弹性中, 检索此卡内容的ID将是会话ID,

因此, 当我们的用户使用会话ID进行第二次请求时, 它会转到另一个EC2实例,

该另一个EC2实例能够使用该会话ID从弹性缓存中查找购物车内容并检索该会话数据｡

最后一个请求, 同样的模式｡ 

真正酷的事情, 我们会记得它是亚毫秒级的性能｡ 

所以所有这些事情都发生得非常快, 这真的很棒｡ 

顺便说一句, 这是存储会话数据的另一种方法｡ 

我们还没看过呢｡ 

它被称为DynamoDB, 但只是把它放在这里, 以防万一你知道DynamoDB是什么｡ 

这是一个很酷的模式｡ 

它更安全, 因为现在弹性缓存是真实的来源, 没有攻击者可以改变弹性缓存中的内容｡

所以我们有一个更安全, 更安全的模式类型, 它是非常常见的｡ 

现在, 我们有了弹性缓存｡ 

我们想明白了｡ 

我们希望将用户数据存储在数据库中, 因此我们希望存储用户地址｡ 

因此, 我们将再次与我们的EC2实例进行通信, 这次它将与RDS实例进行通信,

RDS将非常棒, 因为它用于长期存储｡

因此, 我们可以直接通过与RDS对话来存储和检索用户数据, 如地址名等｡ 

我们的每个实例都可以与我们交谈, 我们有效地再次获得某种多az无状态解决方案｡

所以我们的流量很大, 我们的网站做得很好, 现在我们有越来越多的用户, 我们意识到他们做的最重要的事情是他们浏览网站,

他们阅读, 他们获得产品信息, 所有这些东西｡

那么, 我们如何扩展读取？

我们可以使用一个RDS master来进行写操作, 但是我们也可以使用一些复制的读副本｡

所以任何时候我们读东西, 我们可以从读副本中读取, 我们可以有多达15英寸的RDS,

它们将允许我们扩展我们的RDS数据库的读取｡

还有另一种称为延迟加载的方法, 我们使用缓存｡ 

所以它的工作方式是我们的用户与EC2实例对话, 它在缓存中查看并说,

你有这个信息吗？

如果它没有, 那么它将从RDS读取并将其放回弹性缓存中,

例如缓存信息｡

所以其他EC2实例也在做同样的事情, 但这次当它们与弹性缓存对话时,

它们将获得该信息, 并且它们会获得缓存命中, 因此它们会立即获得响应, 因为它已经被缓存了｡

因此, 这种模式允许我们在RDS上进行更少的流量, 基本上降低了AWS上的CPU使用率,

同时提高了性能｡

但是我们现在需要做缓存维护, 这有点困难, 这也是必须要做的｡ 

应用侧｡ 

太棒了｡ 

现在我们有了应用程序｡ 

它是可扩展的, 它有很多很多的读取, 但我们希望在灾难中幸存下来｡ 

我们不想被灾难打击｡ 

那么, 我们如何与Route 53进行用户对话, 但现在我们必须有一个多az ELB, 顺便说一下, Route

53已经是高度可用的了｡

你不需要做任何事｡ 

但是对于我们的负载均衡器, 我们将使其成为Multi-az我们的自动缩放组是Multi-az,

然后是RDS, 有一个Multi-az功能｡

另一个将是一个备用副本, 可以在发生灾难时接管｡ 

弹性缓存还具有多az功能｡ 

如果用户读到这个｡ 

真的很酷

现在我们基本上有一个全面的multi-az应用程序, 我们确信我们可以在AWS中的可用性区域中生存下来,

现在对于安全组, 我们希望超级安全, 所以也许我们会从任何地方打开Http https流量对于EC2实例端,

我们只想限制来自负载均衡器的流量, 也许来自弹性缓存｡

我们只想限制来自EC2安全组的流量, 同样, 我们想限制直接来自EC2安全组的流量｡

就这样

现在让我们来讨论一下Web应用程序的架构｡ 

因此, 我们已经讨论了ELB粘性会话, 用于存储cookie并使我们的Web应用程序无状态的Web层Web客户端,

或者使用会话ID和会话缓存来使用弹性缓存｡

作为替代, 我们可以使用DynamoDB｡ 

我们还可以使用弹性大小写来在读取时对RDS中的数据进行大小写, 并且我们可以使用Multi-az来在灾难中幸存下来｡

我们可以使用它来存储用户数据｡ 

因此, 更持久类型的数据读取副本可以用于扩展读取, 或者我们也可以使用弹性缓存｡

然后我们有多个AZ用于灾难恢复｡ 

最重要的是, 我们为相互引用的安全组添加了严格的安全性｡ 

这是一个更复杂的应用程序｡ 

有三层, 因为有Web层, 客户端层, Web层和数据库层｡

但总体来说这是一个非常常见的架构｡ 

是的, 它可能会开始增加成本, 但没关系｡ 

至少我们知道我们在做什么交易｡ 

如果我们想要多AZ, 是的, 我们肯定要付出更多｡ 

如果我们想扩大阅读量, 是的, 我们肯定也要付出更多｡ 

但它给了我们一些很好的权衡和架构决策, 我们必须做出｡ 

我希望你们会喜欢, 我们下次课再见.
