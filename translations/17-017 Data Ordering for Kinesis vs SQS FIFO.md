---
source: 17 - Decoupling applications SQS, SNS, Kinesis, Active MQ\017 Data Ordering for Kinesis vs SQS FIFO_zh.srt
---

教师：我们来讲一讲如何为Kinesis和SQS

FIFO排序数据｡

因为尽管这些技术看起来很相似, 也有一些相似的功能,

但它们实际上非常､ 非常､ 非常不同｡

让我们来做个案例研究｡ 

假设您有100辆卡车在路上行驶,

每辆卡车都有一个卡车ID｡

一号车､ 二号车到100号车,

他们在路上,

他们会定期将GPS位置发送到AWS｡

所以我们想按顺序使用每辆卡车的数据, 这样我们就可以准确地跟踪它们的移动,

我们想知道哪里有明显的顺序, 对吗？

那么, 我们应该如何将这些数据发送到Kinesis？

现在的答案是您应该使用分区密钥｡ 

该分区键的值就是卡车ID｡ 

因此, 第一辆卡车会将其发送到第一辆卡车, 然后第二辆卡车会将其发送到第二辆卡车,

以此类推｡

为什么？

因为如果我们指定相同的分区键, 那么相同的键将始终指向相同的分片｡

现在, 让我们看一下图表,

以便更好地理解这一点｡

我们有运动学数据流, 它有三个碎片,

一, 二, 三｡

为了简单起见, 我不会给你们看100辆卡车,

但5辆应该足够了｡

所以我们有五辆卡车, 他们在路上, 他们把数据发送到Kinesis｡

正如我所说的, 我们选择分区密钥为卡车ID｡ 

这意味着, 当我的卡车1发送GPS数据时,

它会将其与分区密钥一起发送到Kinesis, 卡车1和Kinesis会说,

好的, 分区密钥卡车1, 我将对它进行哈希运算, 我的意思是我们将进行计算｡

在这个例子中, 它计算出一号卡车应该进入一号碎片｡

所以我的数据会进入一号碎片｡ 

然后, 卡车2也将发送其数据,

并且将发送卡车2的分区密钥｡

Kinesis会查看这个分区密钥,

并说我已经对它进行了哈希处理, 现在看起来应该进入分片2｡

三号车也一样三号车会上路｡ 

它会派三号车去分区｡ 

但这一次, Kinesis数据流服务将把卡车3作为密钥,

并说你应该去碎片1, 这很好｡

它只是说, 它不一定是分片3, 它只是说,

这个分区密钥应该属于分片1｡

现在, 对于第四辆卡车, 它将转到第三个碎片, 而对于第五辆卡车,

它将转到第二个碎片｡

这就是我们现在的想法, 我们有一个重新分区,

它被称为分区, 因此每个卡车的名称分区密钥在每个碎片上基于分区密钥｡

而且, 由于卡车1不断发送相同的分区密钥,

即卡车1, 因此数据将始终转到相同的碎片｡

因此, 卡车1的下一个数据点将位于碎片1中,

卡车3的下一个数据点也将位于碎片1中,

依此类推｡

因此, 每当卡车1发送数据时, 它都将位于分片1中;每当蓝色卡车､

分片3发送数据时,

它也将位于分片1中,

因为我们指定在一段时间内使用相同的分区密钥｡

我们可以看到, 1号和3号卡车始终将数据存储到1号碎片中｡

现在, 如果我们查看分片2, 则只有2号和5号卡车将数据放入分片2｡

在本例中, 如果您看一下分片3,

我们只有卡车4将其数据发送到分片3｡

现在假设你有100辆卡车和5个碎片,

那么每个碎片平均会有20辆卡车｡

但是没有直接的联系, 你可以分辨出卡车和每个碎片之间的联系｡

Kinesis必须对分区密钥进行哈希运算,

以确定要转到哪个分片｡

我们的想法是,

只要我们有一个稳定的分区密钥,

那么每个卡车将发送此数据到同一个碎片,

因此我们将有数据在碎片级别为每个卡车的顺序｡

讲得通吗？

接下来, 我们将讨论SQS｡ 

我们知道, SQS标准没有排序, 这就是为什么我们有SQL

FIFO, 即先进先出｡

因此, 如果我们在SQL FIFO中不使用组ID,

则所有消息将按发送顺序使用,

并且我们只能有一个客户｡

在本例中, 我们有一组选项, 它们将被发送到SQS

FIFO队列｡

因此, 它们被发送的顺序将是消费者收到它们的顺序｡

正如我们所看到的, 这里只有一个使用者,

它使用两批消息, 第一批和第二批｡

正如我们所看到的, 这是一个先进先出,

这很容易推理｡

所以我们只能有一个消费者｡ 

因此, 如果我们有卡车,

那么所有的卡车都将数据发送到FIFO队列中,

但它们只能是一个消费者｡

因此, 有时您可能希望扩展使用者的数量,

并且希望在消息彼此相关时对消息进行分组｡

因此, 我们可以使用组ID, 这与Kinesis中的分区密钥的概念非常相似｡

因此, 现在使用组ID, 我们的FIFO队列中将有两组FIFO｡

因此, 对于您定义的每个组, 您可以拥有不同的消费者｡

在这个例子中, 我们有两个组, 组A和组B｡ 

而两个消费者消费者一和二可以独立阅读,

组一和组二｡

这里的想法是, 我们拥有的组ID越多, 我们可以拥有的消费者就越多｡

所以这是一个与Kinesis非常不同的模型｡ 

让我们看一下, 如果我们有Kinesis和SQS,

我们有100辆卡车, 5个Kinesis碎片和一个SQS

FIFO队列｡

因此, 如果我们有Kinesis数据流, 那么平均而言,

每个碎片将有大约20辆卡车, 这要归功于哈希,

因此, 每辆卡车将被指定为一个碎片, 并将永远留在该碎片中｡

卡车的数据将在每个碎片中排序｡

但是, 我们可以并行拥有的最大消费者数量只能是5个,

因为我们有5个分片,

每个分片需要一个消费者｡

因此, Kinesis数据流虽然因为它有五个碎片可以接收高达每秒五兆字节的数据,

这是一个相当高的吞吐量｡

现在, 关于SQS FIFO, 您只能有一个SQS

FIFO队列, 明白吗？

所以你不需要定义分片或者分区之类的东西,

你只有一个SQS FIFO队列｡

因为我们有100辆卡车, 所以我们可以创建100个组ID,

每个组ID都等于卡车ID｡

这意味着, 因为我们有100个组ID, 我们可以有多达100个消费者,

好吗？

每个使用者将与一个特定的组ID挂钩｡ 

在规模方面, SQS FIFO每秒最多可处理300条消息,

如果使用批处理, 则可处理3000条消息｡

这是不同的消费模式, 生产模式,

订购模式.

因此, 您必须记住的是,

根据使用案例, 有时使用SQS

FIFO会更好｡

如果您希望根据组ID的数量获得动态数量的消费者, 有时使用Kinesis数据流可能更好,

例如您有10, 000辆卡车, 需要向其发送大量数据, 并且在Kinesis数据流中还具有每个碎片的数据排序｡

我希望这对你们有所帮助,

我知道理解这些东西可能很复杂, 而且它们的水平也比较低,

但是考试开始会问你们一些关于这些的问题, 所以我想确保你们非常清楚地理解这需要什么｡

我希望你们喜欢,

下节课再见.
