---
source: 17 - Decoupling applications SQS, SNS, Kinesis, Active MQ\004 SQS - Message Visibility Timeout_zh.srt
---

教师：现在, 我们来讨论一个重要的概念,

即消息可见性超时｡

因此, 当某个使用者轮询消息时,

其他使用者将看不到该消息｡

让我们举个例子｡ 

时间从左到右, 我们有一个使用者执行ReceiveMessage请求,

因此, 将从队列中返回一条消息｡

现在, 可见性超时开始｡ 

默认情况下, 消息可见性超时为30秒｡

这意味着在这30秒内, 信息必须被处理,

好吗？

如果您这样做,

这意味着如果同一个或其他使用者执行消息请求API调用, 则不会返回该消息｡

在超时窗口期间再次发送一条消息, 则不会返回该消息｡

因此, 在可见性超时期间, 该消息对其他使用者是不可见的｡

但是, 在经过可见性超时之后,

如果消息尚未删除, 则消息将被放回队列中,

因此, 另一个使用者或执行接收消息API调用的同一个使用者将再次收到该消息,

与之前的消息相同｡

所以, 这是非常重要的一点｡ 

如您所见, 当我们收到消息时,

它在可见性超时期间变得不可见｡

现在, 如果我们看一下同一个图, 我们会注意到,

如果我们没有在可见性超时窗口内处理消息,

那么它可能会被处理两次,

对吗？

因为它会被两个不同的消费者接收, 或者被同一个消费者接收两次｡

因此, 如果使用者正在主动处理消息, 但知道它需要多一点时间来处理该消息,

因为否则它将超出可见性超时窗口, 则有一个名为ChangeMessageVisibility的API｡

因此, 如果使用者知道消息需要多一点时间来处理,

而您不想将该消息处理两次, 则使用者应调用ChangeMessageVisibility

API来告诉SQS, 嘿, 现在不要使该消息可见,

好吗？

我只是需要多一点时间来处理这条信息｡ 

那么, 如何设置此消息可见性超时呢？

如果默认情况下将其设置为非常非常高的值,

比如说小时, 那么消费者崩溃时, 将需要几个小时, 直到此消息重新出现, 在SQS队列中重新可见,

这将需要大量时间｡

如果您将其设置为非常非常低的值,

例如几秒, 那么如果使用者由于某种原因没有足够的时间来处理该消息,

那么它将被不同的使用者多次读取, 您可能会得到重复的处理｡

因此, 我们的想法是, 应将可见性超时设置为适合您的应用程序的值,

并且应对您的使用者进行编程, 使其在知道需要更多时间时, 应调用ChangeMessageVisibility API以获得更多时间并增加该可见性窗口的超时｡

但是从考试的角度来理解这个概念是非常重要的,

因为会有关于这个的场景｡

现在, 让我们进入控制台,

看看它在实践中是如何工作的｡

我将打开发送和接收消息的两个窗口,

向大家展示这是如何工作的｡

在第一个窗口中, 我将输入一个hello

world, 它将被发送到队列中｡

如果您还记得的话,

队列的默认超时时间为30秒｡

接下来, 我有两个使用者,

第一个窗口和第二个窗口使用者, 我将从第一个窗口读取消息｡

让我们来轮询消息｡ 

现在我的信息就出现在这里,

它已经被接收了｡

如果我进入第二个消费者并轮询消息, 如您所见,

消息不会出现在这里｡

它没有出现的原因是, 我们仍在该消息的可见性窗口超时范围内,

因此, 在这30秒内, 此消息正试图由该使用者处理, 此时该使用者将看不到它｡

但假设我们停止了投票, 好吗？

因此, 我们不删除该消息, 并且我们知道该消息将在某个时间点超时｡

接下来会发生的是, 是的, 我已经在这里了,

在第二个窗口中, 在第二个使用者中, 这是第二个使用者, 然后消息已经被接收,

因为它被放回了队列中｡

现在, 让我们假设我们做了正确的事情,

我们删除了该消息, 然后我们已经完全处理了该消息｡

但请记住, 这条信息收到了两次｡ 

它说收到的计数是2｡ 

因此, 了解该可见性窗口的工作原理非常重要,

这是一个很好的演示｡

现在, 如果您想更改默认设置, 您可以进入“编辑”,

然后对于可见性超时, 您可以将默认值设置为0秒（绝对不推荐）到12小时之间｡

我认为30秒是可以的, 但请记住, 如果使用者需要更多时间来处理消息,

您只需调用ChangeMessageVisibility API来编辑该消息的可见性并增加该值, 以便另一个使用者不会看到该消息, 而第一个使用者将有足够的时间来相应地处理该消息｡

就这样了｡ 

我希望你们喜欢, 下节课再见｡
